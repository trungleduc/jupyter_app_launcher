"use strict";const CACHE="precache",broadcast=new BroadcastChannel("/sw-api.v1");let enableCache=!1;function onInstall(e){self.skipWaiting(),e.waitUntil(cacheAll())}function onActivate(e){const t=new URL(location.href).searchParams;enableCache="true"===t.get("enableCache"),e.waitUntil(self.clients.claim())}async function onFetch(e){const{request:t}=e,a=new URL(e.request.url);if("/api/service-worker-heartbeat"===a.pathname)return void e.respondWith(new Response("ok"));let n=null;shouldBroadcast(a)?n=broadcastOne(t,a):shouldDrop(t,a)||(n=maybeFromCache(e)),n&&e.respondWith(n)}async function maybeFromCache(e){const{request:t}=e;if(!enableCache)return await fetch(t);let a=await fromCache(t);return a?e.waitUntil(refetch(t)):(a=await fetch(t),e.waitUntil(updateCache(t,a.clone()))),a}async function fromCache(e){const t=await openCache(),a=await t.match(e);return a&&404!==a.status?a:null}async function refetch(e){const t=await fetch(e);return await updateCache(e,t),t}function shouldBroadcast(e){return e.origin===location.origin&&(e.pathname.includes("/api/drive")||e.pathname.includes("/api/stdin/"))}function shouldDrop(e,t){return"GET"!==e.method||null===t.origin.match(/^http/)||t.pathname.includes("/api/")}async function broadcastOne(e,t){const a=await e.json(),n=new Promise((e=>{const t=n=>{const c=n.data;if(c.browsingContextId!==a.browsingContextId)return;const s=c.response;e(new Response(JSON.stringify(s))),broadcast.removeEventListener("message",t)};broadcast.addEventListener("message",t)}));return a.pathname=t.pathname,broadcast.postMessage(a),await n}async function openCache(){return await caches.open(CACHE)}async function updateCache(e,t){return(await openCache()).put(e,t)}async function cacheAll(){const e=await openCache();return await e.addAll([])}self.addEventListener("install",onInstall),self.addEventListener("activate",onActivate),self.addEventListener("fetch",onFetch);