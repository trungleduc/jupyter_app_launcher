{"version":3,"file":"620.6e40be8.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/session/lib/client.js"],"sourcesContent":["import { ServerConnection } from '@jupyterlab/services';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { ArrayExt } from '@lumino/algorithm';\nimport { UUID } from '@lumino/coreutils';\n/**\n * A class to handle requests to /api/sessions\n */\nexport class LiteSessionClient {\n    /**\n     * Construct a new LiteSessionClient.\n     *\n     * @param options The instantiation options for a LiteSessionClient.\n     */\n    constructor(options) {\n        var _a;\n        this._sessions = [];\n        this._pendingRestarts = new Set();\n        this._kernelClient = options.kernelClient;\n        this._serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : ServerConnection.makeSettings();\n        // Listen for kernel removals\n        this._kernelClient.changed.connect((_, args) => {\n            var _a, _b;\n            switch (args.type) {\n                case 'remove': {\n                    const kernelId = (_a = args.oldValue) === null || _a === void 0 ? void 0 : _a.id;\n                    if (!kernelId) {\n                        return;\n                    }\n                    // find the session associated with the kernel\n                    const session = this._sessions.find((s) => { var _a; return ((_a = s.kernel) === null || _a === void 0 ? void 0 : _a.id) === kernelId; });\n                    if (!session) {\n                        return;\n                    }\n                    // Track the kernel ID for restart detection\n                    this._pendingRestarts.add(kernelId);\n                    setTimeout(async () => {\n                        // If after a short delay the kernel hasn't been re-added, it was terminated\n                        if (this._pendingRestarts.has(kernelId)) {\n                            this._pendingRestarts.delete(kernelId);\n                            await this.shutdown(session.id);\n                        }\n                    }, 100);\n                    break;\n                }\n                case 'add': {\n                    // If this was a restart, remove it from pending\n                    const kernelId = (_b = args.newValue) === null || _b === void 0 ? void 0 : _b.id;\n                    if (!kernelId) {\n                        return;\n                    }\n                    this._pendingRestarts.delete(kernelId);\n                    break;\n                }\n            }\n        });\n    }\n    /**\n     * The server settings for the session client.\n     */\n    get serverSettings() {\n        return this._serverSettings;\n    }\n    /**\n     * Get a session by id.\n     *\n     * @param id The id of the session.\n     */\n    async getModel(id) {\n        const session = this._sessions.find((s) => s.id === id);\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        return session;\n    }\n    /**\n     * List the running sessions\n     */\n    async listRunning() {\n        return this._sessions;\n    }\n    /**\n     * Patch an existing session.\n     * This can be used to rename a session.\n     *\n     * - path updates session to track renamed paths\n     * - kernel.name starts a new kernel with a given kernelspec\n     *\n     * @param options The options to patch the session.\n     */\n    async update(options) {\n        const { id, path, name, kernel } = options;\n        const index = this._sessions.findIndex((s) => s.id === id);\n        const session = this._sessions[index];\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        const patched = {\n            ...session,\n            path: path !== null && path !== void 0 ? path : session.path,\n            name: name !== null && name !== void 0 ? name : session.name,\n        };\n        if (kernel) {\n            // Kernel id takes precedence over name.\n            if (kernel.id) {\n                const session = this._sessions.find((session) => { var _a; return ((_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id) === (kernel === null || kernel === void 0 ? void 0 : kernel.id); });\n                if (session) {\n                    patched.kernel = session.kernel;\n                }\n            }\n            else if (kernel.name) {\n                const newKernel = await this._kernelClient.startNew({\n                    id: UUID.uuid4(),\n                    name: kernel.name,\n                    location: PathExt.dirname(patched.path),\n                });\n                if (newKernel) {\n                    patched.kernel = newKernel;\n                }\n                // clean up the session on kernel shutdown\n                void this._handleKernelShutdown({\n                    kernelId: newKernel.id,\n                    sessionId: session.id,\n                });\n            }\n        }\n        this._sessions[index] = patched;\n        return patched;\n    }\n    /**\n     * Start a new session\n     * TODO: read path and name\n     *\n     * @param options The options to start a new session.\n     */\n    async startNew(options) {\n        var _a, _b, _c;\n        const { path, name } = options;\n        const running = this._sessions.find((s) => s.name === name);\n        if (running) {\n            return running;\n        }\n        const kernelName = (_b = (_a = options.kernel) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '';\n        const id = UUID.uuid4();\n        const nameOrPath = (_c = options.name) !== null && _c !== void 0 ? _c : options.path;\n        const dirname = PathExt.dirname(options.name) || PathExt.dirname(options.path);\n        const hasDrive = nameOrPath.includes(':');\n        const driveName = hasDrive ? nameOrPath.split(':')[0] : '';\n        // add drive name if missing (top level directory)\n        const location = dirname.includes(driveName) ? dirname : `${driveName}:${dirname}`;\n        const kernel = await this._kernelClient.startNew({\n            id,\n            name: kernelName,\n            location,\n        });\n        const session = {\n            id,\n            path,\n            name: name !== null && name !== void 0 ? name : path,\n            type: 'notebook',\n            kernel: {\n                id: kernel.id,\n                name: kernel.name,\n            },\n        };\n        this._sessions.push(session);\n        // clean up the session on kernel shutdown\n        void this._handleKernelShutdown({ kernelId: id, sessionId: session.id });\n        return session;\n    }\n    /**\n     * Shut down a session.\n     *\n     * @param id The id of the session to shut down.\n     */\n    async shutdown(id) {\n        var _a;\n        const session = this._sessions.find((s) => s.id === id);\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        const kernelId = (_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id;\n        if (kernelId) {\n            await this._kernelClient.shutdown(kernelId);\n        }\n        ArrayExt.removeFirstOf(this._sessions, session);\n    }\n    /**\n     * Shut down all sessions.\n     */\n    async shutdownAll() {\n        await Promise.all(this._sessions.map((s) => this.shutdown(s.id)));\n    }\n    /**\n     * Handle kernel shutdown\n     */\n    async _handleKernelShutdown({ kernelId, sessionId, }) {\n        // No need to handle kernel shutdown here anymore since we're using the changed signal\n    }\n}\n//# sourceMappingURL=client.js.map"],"names":["LiteSessionClient","constructor","options","_a","this","_sessions","_pendingRestarts","Set","_kernelClient","kernelClient","_serverSettings","serverSettings","ServerConnection","makeSettings","changed","connect","_","args","_b","type","kernelId","oldValue","id","session","find","s","kernel","add","setTimeout","async","has","delete","shutdown","newValue","getModel","Error","listRunning","update","path","name","index","findIndex","patched","newKernel","startNew","UUID","uuid4","location","PathExt","dirname","_handleKernelShutdown","sessionId","_c","running","kernelName","nameOrPath","driveName","includes","split","push","ArrayExt","removeFirstOf","shutdownAll","Promise","all","map"],"sourceRoot":""}